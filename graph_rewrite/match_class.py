# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_match_class.ipynb.

# %% auto 0
__all__ = ['convert_to_edge_name', 'is_anonymous_node', 'Match', 'mapping_to_match']

# %% ../nbs/02_match_class.ipynb 4
import networkx as nx
from networkx import DiGraph
from typing import *

# %% ../nbs/02_match_class.ipynb 6
def convert_to_edge_name(src: Hashable, dest: Hashable) -> str:
    return f"{src}->{dest}"

# %% ../nbs/02_match_class.ipynb 8
def is_anonymous_node(node_name: Hashable) -> bool:
    return len(node_name) >= 1 and node_name[0] == '$'

# %% ../nbs/02_match_class.ipynb 11
class Match:
    def __init__(self, graph: DiGraph, nodes: List[Hashable], edges: List[Tuple[Hashable, Hashable]], mapping: Dict[str, Hashable]):
        self.graph: DiGraph = graph
        self.__nodes: List[Hashable] = nodes
        self.__edges: List[Tuple[Hashable, Hashable]] = edges
        self.mapping: Dict[str, Hashable] = mapping

    class DoesNotExist(Exception):
        pass

    def __get_node(self, pattern_node):
        return self.graph.nodes[self.mapping[pattern_node]]

    def __get_edge(self, pattern_src, pattern_dst):
        if (pattern_src, pattern_dst) not in self.__edges:
            raise self.DoesNotExist
        return self.graph.edges[self.mapping[pattern_src], self.mapping[pattern_dst]]

    def nodes(self):
        return {pattern_node: self.__get_node(pattern_node) for pattern_node in self.__nodes}

    def edges(self):
        return {convert_to_edge_name(pattern_src, pattern_dest): self.__get_edge(pattern_src, pattern_dest) for (pattern_src, pattern_dest) in self.__edges}

    def __getitem__(self, key: Hashable):
        try:
            if str(key).__contains__("->") and len(str(key).split("->")) == 2:
                end_nodes = str(key).split("->")
                return self.__get_edge(end_nodes[0], end_nodes[1])
            else:
                return self.__get_node(key)
        except:
            raise self.DoesNotExist

# %% ../nbs/02_match_class.ipynb 13
def mapping_to_match(input: DiGraph, pattern: DiGraph, mapping: Dict[str, Hashable]) -> Match:
    nodes_list, edges_list = [], []
    cleared_mapping = mapping.copy()

    for pattern_node in mapping.keys():
        if is_anonymous_node(pattern_node):
            cleared_mapping.pop(pattern_node)
            continue # as we don't want to include this node in the Match
        nodes_list.append(pattern_node)

    for (n1, n2) in pattern.edges:
        if is_anonymous_node(n1) or is_anonymous_node(n2):
            continue # as before
        edges_list.append((n1, n2))

    return Match(input, nodes_list, edges_list, cleared_mapping)
