# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_match_class.ipynb.

# %% auto 0
__all__ = ['logger', 'is_anonymous_node', 'Match', 'mapping_to_match', 'draw_match']

# %% ../nbs/02_match_class.ipynb 5
import networkx as nx
from networkx import DiGraph
from typing import *
from .core import _create_graph, draw, GraphRewriteException, NodeName, EdgeName
from itertools import product
from collections import defaultdict
import logging

# %% ../nbs/02_match_class.ipynb 7
logger = logging.getLogger(__name__)    

# %% ../nbs/02_match_class.ipynb 14
def _convert_to_edge_name(src: NodeName, dest: NodeName) -> str:
    """Given a pair of node names, source and destination, return the name of the edge
    connecting the two in the format {src}->{dest}, which is the same format the parser
    uses to create edges in the pattern graph.

    Args:
        src (NodeName): A node name
        dest (NodeName): A node name

    Returns:
        str: A representative name for the edge (src, dest).
    """
    return f"{src}->{dest}"

# %% ../nbs/02_match_class.ipynb 16
def is_anonymous_node(node_name: NodeName) -> bool:
    """Given a name of a node in the pattern graph, return true if it begins with '$',
    which is the notion the parser uses to denote anonymous nodes.

    Args:
        node_name (NodeName): A node name in the pattern

    Returns:
        bool: Returns True if the node is anonymous, False otherwise.
    """
    return len(node_name) >= 1 and node_name.startswith('_anonymous_node_')

# %% ../nbs/02_match_class.ipynb 21
class Match:
    """
    Represents a single match of a pattern inside an input graph.
    Provides a subview to a graph, limited to the nodes, edges, and attributes specified in the pattern.
    """
    def __init__(self, input_graph: DiGraph, pattern_nodes: List[NodeName], single_nodes: set[NodeName], 
                 pattern_edges: List[EdgeName], mapping: Dict[NodeName, set[NodeName]], 
                 warn_on_collisions: bool = True):
        """
        Initialize the Match object.

        Args:
            input_graph (DiGraph): The input graph.
            pattern_nodes (List[NodeName]): The nodes in the pattern (including anonymous nodes).
            single_nodes (Set[NodeName]): The single nodes in the pattern (including anonymous nodes).
            pattern_edges (List[EdgeName]): The edges in the pattern (including anonymous edges).
            mapping (Dict[NodeName, Set[NodeName]]): The mapping from pattern nodes to input graph nodes.
            filter (bool): Whether to filter out anonymous nodes and edges from the match.
            warn_on_collisions (bool): Whether to warn if there are collisions in the mapping.
        """
        self.graph = input_graph
        self._nodes = pattern_nodes
        self._single_nodes = single_nodes
        self._edges = pattern_edges
        self.mapping = mapping
        if warn_on_collisions:
            self._check_for_collisions()

    def _check_for_collisions(self) -> None:
        """
        Check if there are any collisions in the mapping - i.e., if the same input node is mapped to multiple
        pattern nodes. If there are, print a warning specifying the input nodes that are being mapped to multiple
        pattern nodes.
        """
        input_to_pattern_nodes = defaultdict(set)
        for pattern_node in self._nodes:
            for input_node in self.mapping[pattern_node]:
                input_to_pattern_nodes[input_node].add(pattern_node)
                if len(input_to_pattern_nodes[input_node]) > 1:
                    logger.warning(f"Input node {input_node} is mapped to multiple pattern nodes: {input_to_pattern_nodes[input_node]}") 
        return 
                
    def _check_node_in_pattern(self, pattern_node: NodeName):
        """Ensure that the pattern node exists in the pattern being matched."""
        if pattern_node not in self._nodes:
            raise GraphRewriteException(f"Node {pattern_node} does not exist in the pattern")

    def _check_edge_in_pattern(self, pattern_src: NodeName, pattern_dst: NodeName):
        """Ensure that the pattern edge exists in the pattern being matched."""
        if (pattern_src, pattern_dst) not in self._edges:
            raise GraphRewriteException(f"Edge {(pattern_src, pattern_dst)} does not exist in the pattern")

    def _check_node_in_graph(self, input_node: NodeName):
        """Ensure that the input node exists in the input graph."""
        if input_node not in self.graph.nodes:
            raise GraphRewriteException(f"Node {input_node} does not exist in the input graph")

    def _check_edge_in_graph(self, input_src: NodeName, input_dst: NodeName):
        """Ensure that the input edge exists in the input graph."""
        if (input_src, input_dst) not in self.graph.edges:
            raise GraphRewriteException(f"Edge {(input_src, input_dst)} does not exist in the input graph")

    def is_single(self, pattern_node: NodeName) -> bool:
        """Check if the pattern node requires an single."""
        return pattern_node in self._single_nodes

    def __get_node(self, pattern_node):
        """
        Returns the node or the collection of nodes mapped to the pattern node.

        Args:
            pattern_node: The node in the pattern.

        Returns:
            The node or the collection of nodes mapped to the pattern node.
        """
        if pattern_node == '_':
            raise GraphRewriteException("Anonymous nodes cannot be accessed directly")

        self._check_node_in_pattern(pattern_node)
        input_nodes = list(self.mapping[pattern_node])

        # Ensure all input nodes exist in the graph
        for input_node in input_nodes:
            self._check_node_in_graph(input_node)

        # Return the single matched node if it's a single node
        if self.is_single(pattern_node):
            return self.graph.nodes[input_nodes[0]]

        # Otherwise, return the collection of nodes
        return [self.graph.nodes[input_node] for input_node in input_nodes]

    def __get_edge(self, pattern_src, pattern_dst):
        """
        Returns the edge or the collection of edges mapped to the pattern edge.

        Args:
            pattern_src: The source node in the pattern.
            pattern_dst: The destination node in the pattern.

        Returns:
            The edge (if both source and destination nodes are single nodes) or collection of edges (if collections).
        """
        self._check_edge_in_pattern(pattern_src, pattern_dst)
        input_src_nodes = self.mapping[pattern_src]
        input_dst_nodes = self.mapping[pattern_dst]

        # Return the single edge if both source and destination nodes are single nodes
        if self.is_single(pattern_src) and self.is_single(pattern_dst):
            input_src_node = list(input_src_nodes)[0]
            input_dst_node = list(input_dst_nodes)[0]
            self._check_edge_in_graph(input_src_node, input_dst_node)
            return self.graph.edges[(input_src_node, input_dst_node)]

        input_edges = []
        for (src, dst) in product(input_src_nodes, input_dst_nodes):
            if self.graph.has_edge(src, dst):
                input_edges.append(self.graph.edges[(src, dst)])  # Add matching edge to the collection

        if not input_edges:
            raise GraphRewriteException(f"No edges found between {pattern_src} and {pattern_dst}.")
        return input_edges

    def set_graph(self, graph: DiGraph):
        """Update the graph associated with this match."""
        self.graph = graph

    def remove_anonymous_nodes_and_edges(self):
        """Remove anonymous nodes and edges from the match."""
        for node in list(self._nodes): # Use list() to avoid modifying the set while iterating
            if is_anonymous_node(node):
                self._nodes.remove(node)

        for edge in list(self._edges): # Use list() to avoid modifying the set while iterating
            if is_anonymous_node(edge[0]) or is_anonymous_node(edge[1]):
                self._edges.remove(edge)

        for node in list(self.mapping.keys()):
            if is_anonymous_node(node):
                self.mapping.pop(node)

    def __eq__(self, other):
        """Check if two matches are equal based on their node mappings."""
        if isinstance(other, Match) and len(other.mapping) == len(self.mapping):
            return all(other.mapping.get(k) == v for k, v in self.mapping.items())
        return False

    def __getitem__(self, key: Union[NodeName, str]):
        """
        Access the node or edge (single or collection) from the input graph based on the pattern.

        Args:
            key (Union[NodeName, str]): The pattern node or edge name to access.

        Returns:
            The corresponding node(s) or edge(s).
        """
        try:
            # Handle edges (using the "node1->node2" format)
            if "->" in str(key) and len(str(key).split("->")) == 2:
                src, dst = key.split("->")
                edge_or_edges = self.__get_edge(src, dst)

                if self.is_single(src) and self.is_single(dst):
                    return edge_or_edges
                return EdgeCollectionView(edge_or_edges)  # set of edges

            # Handle nodes
            node_or_nodes = self.__get_node(key)

            if self.is_single(key):
                return node_or_nodes
            return NodeCollectionView(node_or_nodes)  # set of nodes

        except KeyError:
            raise GraphRewriteException(f"The symbol {key} does not exist in the pattern, or it was removed from the graph")

    def __str__(self):
        """Return a string representation of the match's node mapping."""
        return str(self.mapping)
    
    def get_pattern_nodes(self):
        """Return the pattern nodes."""
        return self._nodes
    
    def get_pattern_edges(self):
        """Return the pattern edges."""
        return self._edges

# %% ../nbs/02_match_class.ipynb 23
def mapping_to_match(input_graph: DiGraph, single_pattern: DiGraph, collections_pattern: DiGraph, 
                     mapping: Dict[NodeName, Set[NodeName]], warn_on_collisions: bool=True) -> Match:
    """
    Convert a given mapping (which represents a match between the pattern and the input graph) 
    into an instance of the Match class, which provides a subgraph view based on nodes and edges.

    Args:
        input_graph (DiGraph): The input graph where matches are found.
        single_pattern (DiGraph): A pattern graph representing nodes that require an single in the input graph.
        collections_pattern (DiGraph): A pattern graph representing nodes that match multiple input nodes (collections).
        mapping (Dict[NodeName, Set[NodeName]]): The mapping of pattern nodes to corresponding input graph nodes.
        filter (bool): If True, anonymous nodes (those starting with '_') are excluded from the match.

    Returns:
        Match: An instance of the Match class representing the match for the given mapping.
    """

    pattern_nodes = list(mapping.keys())

    single_nodes = set(single_pattern.nodes)

    pattern_edges = list(set(single_pattern.edges) | set(collections_pattern.edges))

    return Match(input_graph, pattern_nodes, single_nodes, pattern_edges, mapping, warn_on_collisions)

# %% ../nbs/02_match_class.ipynb 42
def draw_match(g, m, **kwargs):
    """
    Draw the input graph with the nodes and edges that are part of the match highlighted.
    
    Args:
        g (DiGraph): The input graph to draw.
        m (Match): The match object representing the nodes and edges to highlight.
        **kwargs: Additional keyword arguments to pass to the draw function

    Returns:
        None
    """
    g_copy = g.copy()
    node_styles = {}
    edge_styles = {}

    # Reverse mapping with defaultdict for handling multiple pattern nodes per input node
    reverse_mapping = defaultdict(list)
    for pattern_node, input_nodes in m.mapping.items():
        for input_node in input_nodes:
            reverse_mapping[input_node].append(pattern_node)

    # Handle node styling
    for input_node, pattern_nodes in reverse_mapping.items():
        if len(pattern_nodes) > 1: # Collection node
            for pattern_node in pattern_nodes:
                node_styles[input_node] = 'stroke:red,stroke-width:4px;'
                g_copy.nodes[input_node]['label'] = f"{pattern_node}_{input_node}"
        else: # Single node
            node_styles[input_node] = 'stroke:blue,stroke-width:4px;'
            g_copy.nodes[input_node]['label'] = pattern_nodes[0]

    for u, v in m._edges:
        edge_styles.update({(input_u, input_v): 'stroke:blue,stroke-width:4px;'
                            for input_u, input_v in product(m.mapping.get(u, []), m.mapping.get(v, []))})

    draw(g_copy, node_styles=node_styles, edge_styles=edge_styles, **kwargs)

