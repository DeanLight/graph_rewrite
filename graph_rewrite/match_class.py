# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_match_class.ipynb.

# %% auto 0
__all__ = ['is_anonymous_node', 'Match', 'mapping_to_match', 'draw_match']

# %% ../nbs/02_match_class.ipynb 5
import networkx as nx
from networkx import DiGraph
from typing import *
from .core import _create_graph, draw, GraphRewriteException, NodeName, EdgeName
from itertools import product
from collections import defaultdict

# %% ../nbs/02_match_class.ipynb 12
def _convert_to_edge_name(src: NodeName, dest: NodeName) -> str:
    """Given a pair of node names, source and destination, return the name of the edge
    connecting the two in the format {src}->{dest}, which is the same format the parser
    uses to create edges in the pattern graph.

    Args:
        src (NodeName): A node name
        dest (NodeName): A node name

    Returns:
        str: A representative name for the edge (src, dest).
    """
    return f"{src}->{dest}"

# %% ../nbs/02_match_class.ipynb 14
def is_anonymous_node(node_name: NodeName) -> bool:
    """Given a name of a node in the pattern graph, return true if it begins with '$',
    which is the notion the parser uses to denote anonymous nodes.

    Args:
        node_name (NodeName): A node name in the pattern

    Returns:
        bool: Returns True if the node is anonymous, False otherwise.
    """
    return len(node_name) >= 1 and node_name[0] == '_'

# %% ../nbs/02_match_class.ipynb 20
class Match:
    """
    Represents a single match of a pattern inside an input graph.
    Provides a subview to a graph, limited to the nodes, edges, and attributes specified in the pattern.
    """
    def __init__(self, graph: DiGraph, nodes: List[NodeName], edges: List[EdgeName], 
                 mapping: Dict[NodeName, set[NodeName]], single_nodes: set[NodeName]
                 , warn_on_collisions: bool = True):
        """
        Initialize the Match object.

        Args:
            graph (DiGraph): The input graph being matched.
            nodes (List[NodeName]): List of pattern nodes included in this match.
            edges (List[EdgeName]): List of pattern edges included in this match.
            mapping (Dict[NodeName, Set[NodeName]]): Mapping from pattern nodes to input graph nodes.
            single_nodes (Set[NodeName]): Set of pattern nodes for which we map a single input graph node.
            warn_on_collisions (bool): Flag to warn the user if there are any collisions in the mapping (default: True).
        """
        self.graph = graph
        self._nodes = nodes
        self._edges = edges
        self.mapping = mapping  # Pattern nodes are mapped to sets of input graph nodes (for collections)
        self.single_nodes = single_nodes  # Nodes requiring a mapping to a single input graph node (non-collections)
        self._warn_on_collisions = warn_on_collisions
        if self._warn_on_collisions:
            self._check_for_collisions(self.mapping)

    def _check_for_collisions(self, mapping: Dict[NodeName, set[NodeName]]) -> Dict[NodeName, set[NodeName]]:
        """
        Check if there are any collisions in the mapping - i.e., if the same input node is mapped to multiple
        pattern nodes. If there are, print a warning specifying the input nodes that are being mapped to multiple
        pattern nodes.

        Args:
            mapping (Dict[NodeName, Set[NodeName]]): Mapping from pattern nodes to input graph nodes.

        Returns:
            Dict[NodeName, Set[NodeName]]: The mapping with any collisions resolved.
        """
        pattern_nodes = mapping.keys()
        input_nodes = mapping.values()
        
        for input_node in input_nodes:
            matched_pattern_nodes = [pattern_node for pattern_node in pattern_nodes 
                                     if input_node in mapping[pattern_node]]
            if len(matched_pattern_nodes) > 1:
                    #TODO: use logging instead of print
                    print(f"Warning: Input node {input_node} is mapped to multiple pattern nodes: {matched_pattern_nodes}")
        return mapping
                
    def _check_node_in_pattern(self, pattern_node: NodeName):
        """Ensure that the pattern node exists in the pattern being matched."""
        if pattern_node not in self._nodes:
            raise GraphRewriteException(f"Node {pattern_node} does not exist in the pattern")

    def _check_edge_in_pattern(self, pattern_src: NodeName, pattern_dst: NodeName):
        """Ensure that the pattern edge exists in the pattern being matched."""
        if (pattern_src, pattern_dst) not in self._edges:
            raise GraphRewriteException(f"Edge {(pattern_src, pattern_dst)} does not exist in the pattern")

    def _check_node_in_graph(self, input_node: NodeName):
        """Ensure that the input node exists in the input graph."""
        if input_node not in self.graph.nodes:
            raise GraphRewriteException(f"Node {input_node} does not exist in the input graph")

    def _check_edge_in_graph(self, input_src: NodeName, input_dst: NodeName):
        """Ensure that the input edge exists in the input graph."""
        if (input_src, input_dst) not in self.graph.edges:
            raise GraphRewriteException(f"Edge {(input_src, input_dst)} does not exist in the input graph")

    def _is_single(self, pattern_node: NodeName) -> bool:
        """Check if the pattern node requires an single."""
        return pattern_node in self.single_nodes

    def __get_node(self, pattern_node):
        """
        Returns the node or the collection of nodes mapped to the pattern node.

        Args:
            pattern_node: The node in the pattern.

        Returns:
            The node or the collection of nodes mapped to the pattern node.
        """
        self._check_node_in_pattern(pattern_node)
        input_nodes = list(self.mapping[pattern_node])

        # Ensure all input nodes exist in the graph
        for input_node in input_nodes:
            self._check_node_in_graph(input_node)

        # Return the single matched node if it's a single node
        if self._is_single(pattern_node):
            return self.graph.nodes[input_nodes[0]]

        # Otherwise, return the collection of nodes
        return [self.graph.nodes[input_node] for input_node in input_nodes]

    def __get_edge(self, pattern_src, pattern_dst):
        """
        Returns the edge or the collection of edges mapped to the pattern edge.

        Args:
            pattern_src: The source node in the pattern.
            pattern_dst: The destination node in the pattern.

        Returns:
            The edge (if both source and destination nodes are single nodes) or collection of edges (if collections).
        """
        self._check_edge_in_pattern(pattern_src, pattern_dst)
        input_src_nodes = self.mapping[pattern_src]
        input_dst_nodes = self.mapping[pattern_dst]

        # Return the single edge if both source and destination nodes are single nodes
        if self._is_single(pattern_src) and self._is_single(pattern_dst):
            input_src_node = list(input_src_nodes)[0]
            input_dst_node = list(input_dst_nodes)[0]
            self._check_edge_in_graph(input_src_node, input_dst_node)
            return self.graph.edges[(input_src_node, input_dst_node)]

        input_edges = []
        for (src, dst) in product(input_src_nodes, input_dst_nodes):
            if self.graph.has_edge(src, dst):
                input_edges.append(self.graph.edges[(src, dst)])  # Add matching edge to the collection

        if not input_edges:
            raise GraphRewriteException(f"No edges found between {pattern_src} and {pattern_dst}.")
        return input_edges


    def nodes(self):
        """Return all nodes involved in this match, including collections."""
        return {pattern_node: self.__get_node(pattern_node) for pattern_node in self._nodes}

    def edges(self):
        """Return all edges involved in this match, including collections."""
        return {
            _convert_to_edge_name(pattern_src, pattern_dest): self.__get_edge(pattern_src, pattern_dest) 
            for (pattern_src, pattern_dest) in self._edges
        }

    def set_graph(self, graph: DiGraph):
        """Update the graph associated with this match."""
        self.graph = graph

    def __eq__(self, other):
        """Check if two matches are equal based on their node mappings."""
        if isinstance(other, Match) and len(other.mapping) == len(self.mapping):
            return all(other.mapping.get(k) == v for k, v in self.mapping.items())
        return False

    def __getitem__(self, key: Union[NodeName, str]):
        """
        Access the node or edge (single or collection) from the input graph based on the pattern.

        Args:
            key (Union[NodeName, str]): The pattern node or edge name to access.

        Returns:
            The corresponding node(s) or edge(s).
        """
        try:
            # Handle edges (using the "node1->node2" format)
            if "->" in str(key) and len(str(key).split("->")) == 2:
                src, dst = key.split("->")
                edge_or_edges = self.__get_edge(src, dst)

                if self._is_single(src) and self._is_single(dst):
                    return edge_or_edges
                return EdgeCollectionView(edge_or_edges)  # set of edges

            # Handle nodes
            node_or_nodes = self.__get_node(key)

            if self._is_single(key):
                return node_or_nodes
            return NodeCollectionView(node_or_nodes)  # set of nodes

        except KeyError:
            raise GraphRewriteException(f"The symbol {key} does not exist in the pattern, or it was removed from the graph")

    def __str__(self):
        """Return a string representation of the match's node mapping."""
        return str(self.mapping)

# %% ../nbs/02_match_class.ipynb 22
def mapping_to_match(input_graph: DiGraph, single_pattern: DiGraph, collections_pattern: DiGraph, 
                     mapping: Dict[NodeName, Set[NodeName]], filter: bool=True) -> Match:
    """
    Convert a given mapping (which represents a match between the pattern and the input graph) 
    into an instance of the Match class, which provides a subgraph view based on nodes and edges.

    Args:
        input_graph (DiGraph): The input graph where matches are found.
        single_pattern (DiGraph): A pattern graph representing nodes that require an single in the input graph.
        collections_pattern (DiGraph): A pattern graph representing nodes that match multiple input nodes (collections).
        mapping (Dict[NodeName, Set[NodeName]]): The mapping of pattern nodes to corresponding input graph nodes.
        filter (bool): If True, anonymous nodes (those starting with '_') are excluded from the match.

    Returns:
        Match: An instance of the Match class representing the match for the given mapping.
    """
    nodes_list = []
    edges_list = []

    # Copy mapping to a new dictionary for filtering purposes
    cleared_mapping = mapping
    
    # Filter out anonymous nodes if needed
    anonymous_nodes_to_remove = []
    if filter:
        for pattern_node in mapping.keys():
            if is_anonymous_node(pattern_node):
                anonymous_nodes_to_remove.append(pattern_node)

        for node in anonymous_nodes_to_remove:
            cleared_mapping.pop(node)

    # Collect the nodes that passed the filtering process
    nodes_list = list(cleared_mapping.keys())

    # Process edges in the pattern and filter out any that include anonymous nodes if needed
    for (src, dst) in single_pattern.edges | collections_pattern.edges:
        if filter and (is_anonymous_node(src) or is_anonymous_node(dst)):
            continue
        edges_list.append((src, dst))

    return Match(input_graph, nodes_list, edges_list, cleared_mapping, set(single_pattern.nodes))

# %% ../nbs/02_match_class.ipynb 42
def draw_match(g, m, **kwargs):
    """
    Draw the input graph with the nodes and edges that are part of the match highlighted.
    
    Args:
        g (DiGraph): The input graph to draw.
        m (Match): The match object representing the nodes and edges to highlight.
        **kwargs: Additional keyword arguments to pass to the draw function

    Returns:
        None
    """
    g_copy = g.copy()
    node_styles = {}
    edge_styles = {}

    # Reverse mapping with defaultdict for handling multiple pattern nodes per input node
    reverse_mapping = defaultdict(list)
    for pattern_node, input_nodes in m.mapping.items():
        for input_node in input_nodes:
            reverse_mapping[input_node].append(pattern_node)

    # Handle node styling
    for input_node, pattern_nodes in reverse_mapping.items():
        if len(pattern_nodes) > 1: # Collection node
            for pattern_node in pattern_nodes:
                node_styles[input_node] = 'stroke:red,stroke-width:4px;'
                g_copy.nodes[input_node]['label'] = f"{pattern_node}_{input_node}"
        else: # Single node
            node_styles[input_node] = 'stroke:blue,stroke-width:4px;'
            g_copy.nodes[input_node]['label'] = pattern_nodes[0]

    for u, v in m._edges:
        edge_styles.update({(input_u, input_v): 'stroke:blue,stroke-width:4px;'
                            for input_u, input_v in product(m.mapping.get(u, []), m.mapping.get(v, []))})

    draw(g_copy, node_styles=node_styles, edge_styles=edge_styles, **kwargs)

