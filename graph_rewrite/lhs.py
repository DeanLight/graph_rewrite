# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_lhs_parsing.ipynb.

# %% auto 0
__all__ = ['cnt', 'lhsTransformer', 'lhs_to_graph']

# %% ../nbs/01_lhs_parsing.ipynb 6
import itertools
import copy
import networkx as nx

# %% ../nbs/01_lhs_parsing.ipynb 7
cnt:int = 0 # unique id for anonymous vertices
from lark import Tree, Transformer
class lhsTransformer(Transformer):
    def __init__(self, visit_tokens: bool = True) -> None:
        super().__init__(visit_tokens)
        self.constraints = {}
        self.cnt = 0

    def STRING(self, arg):
        return arg[1:-1] # remove " "
    
    def BOOLEAN(self, arg):
        return bool(arg)
    
    def INT(self, arg): # can be negative
        return int(arg)
    
    def FLOAT(self, arg):
        return float(arg)
    
    def NATURAL_NUMBER(self, number): # for duplications
        return int(number)
    
    def value(self,arg):
        return arg
    
    def attribute(self, args): #(attr_name, *rest):
        attr_name = args[0]
        if len(args) == 3:
            type, value = args[1:]
        elif len(args) == 2:
            # CHANGE!
            print("parsed: " + args[1])
            value = None
            type = None
        # pass a tuple of attr_name, required type, required value.
        return (attr_name, type, value) # constraints are handled in other transformer.
    
    def attributes(self, attributes): # a list of triples 
        # return a packed list of the attribute names.
        attr_names, constraints = {}, {}
        for attribute in attributes:
            # print(attribute)
            attr_names[str(attribute[0])] = None # will be added to the graph itself
            constraints[attribute[0]] = (attribute[1], attribute[2]) # will be added to the condition function
        return (attr_names, constraints)

    def multi_connection(self, args): # +
        # return the list of attributes(strings), add a special attribute to denote number of duplications.
        #   for "-+->" implementation also return FALSE if "+" is parsed (indicating that the connection is not deterministic)
        number, attributes = args
        attributes[0]["$dup"] = number # removed in graph construction
        return attributes

    def connection(self, attributes): # (dict of attributes, constraints: attribute -> (val,type))
        # return the packed list of attributes received, num_duplications = 1, is_deterministic = True
        attributes[0]["$dup"] = 1
        return (attributes, True)

    def ANONYMUS(self): #
        # return a dedicated name for anonymus (string), and an empty list.
        x = ("$" + str(cnt), [])
        self.cnt += 1
        return x

    def index_vertex(self, args):
        # return the main name of the vertex, and a list of the indices specified.
        main_name_tup, *numbers = args #numbers is a list
        # print(main_name_tup)
        # print(numbers)
        return (main_name_tup[0], list(numbers))
    
    def NAMED_VERTEX(self, name):
        # return the main name of the vertex, and an empty list.
        return (name, [])

    def vertex(self, args): # (vertex_tuple: tuple, attributes: dict = {})
        # return arguments
        vertex_tuple, *attributes = args # attributes is a empty list/ a list containing a tuple: (names dict, constraints dict)
        name, indices_list = vertex_tuple 
        if indices_list == None:
            indices_list = []
        indices = ",".join([str(num) for num in indices_list])
        new_name = name + "<"
        new_name = new_name + indices + ">" # numbers are strings, no convertion needed.
        if len(attributes) == 0:
            return (new_name, {})
        # now that we have the vertex name we add the attribute constraints:
        # vertices may appear multiple times in LHS thus we unite the constraints. We assume there cannot be contradicting constraints.
        self.constraints[new_name] = self.constraints[new_name] | attributes[0][1] # the second element of the tuple is the constraints dict: attr_name -> (value,type)
        return (new_name, attributes[0][0]) #(string, dict)

    def pattern(self, args):
        # 1) unpack lists of vertices and connections.
        vertex, *rest = args
        conn, vertices = list(rest)[::2], list(rest)[1::2]
        vertices.insert(0,vertex)
        # print(vertices)
        # print(conn)
        # 2) create a networkX graph:
            # Future feature: if there is a special attribute with TRUE (deterministic), dumplicate the connection $dup times.
        G = nx.DiGraph()

        # simplified vertion - ignore duplications
        G.add_nodes_from(vertices)
        edge_list = []
        for i,edge in enumerate(conn):
            # for now the duplication feature is not included so we remove the $dup attribute
            attribute_names, constraints = edge[0]
            attribute_names.pop("$dup", 0)
            edge_list.append((vertices[i], vertices[i+1], attribute_names)) # ignore edge[1] - determinism flag. edge[0] is the tuple of dicts of attributes.
            # add constraints - we assume an edge only appears once in LHS
            self.constraints[str(vertices[i]) + "->" + str(vertices[i+1])] = constraints

        # more complex vertion - duplications
        # create a recursive function that adds the vertices and edges, 
        # that calls itself by the number of duplications on each level.
        G.add_edges_from(edge_list)
        return G

    def patterns(self, g, *graphs):
        patterns = list(graphs)
        patterns.insert(0,g)
        # unite all the patterns into a single graph
        G = nx.DiGraph()

        combined_attributes = dict() # dict of dicts (node_name -> attribute -> value)
        new_nodes = []
        new_edges = []
        for graph in patterns:
            for node in graph.nodes:
                combined_attributes[node] = combined_attributes[node] | graph.nodes.data()[node]
                new_nodes.append(node) #unite the dicts for each
            for edge in graph.edges:
                # we assumed edges cannot appear more than once in LHS
                combined_attributes[edge[0] + "->" + edge[1]] = graph.edges[edge[0],edge[1]]
                new_edges.append(edge)

        G.add_nodes_from([(node, combined_attributes[node]) for node in new_nodes])
        G.add_edges_from([(node1, node2, combined_attributes[node1 + "->" + node2]) for (node1,node2) in new_edges])

        return (G, copy.deepcopy(self.constraints)) #sent as a module output and replaces condition.

# %% ../nbs/01_lhs_parsing.ipynb 9
from .match_class import Match
def lhs_to_graph(lhs: str, condition):
    """Given an LHS pattern and a condition function, return the directed graph represented by the pattern, 
    along with an updated condition function that combines the original constraints and the new value and type constraints
    deriving from the pattern.

    Args:
        lhs (string): A string in lhs format 
        condition (lambda: Match -> bool): A function supplied by the user specifying additional 
                                           constraints on the graph components.

    Returns:
        DiGraph, lambda: Match->bool: a networkx graph that is the graph represented by the pattern, 
                                      and an extended condition function as mentioned above.
    """
    tree = lhs_parser.parse(lhs)
    final_graph, constraints = lhsTransformer().transform(tree)
    # constraints is a dictionary: vertex/edge -> {attr_name: (value, type), ...}

    # add the final constraints to the "condition" function
    def type_condition(match: Match):
        flag = True
        for graph_obj in constraints.keys():
            obj_constraints = constraints[graph_obj]
            for attr_name in obj_constraints.keys():
                required_type, required_value = obj_constraints[attr_name]

                # check value constraint
                if required_value != None:
                    if not hasattr(required_value, '__eq__') or (not required_value == match[v][attr_name]):
                        flag = False
                
                # check type constraint only of value was not checked
                elif required_type != None and not isinstance(match[v][attr_name], required_type):
                    flag = False

        return flag and condition(match) # True <=> the match satisfies all the constraints.
            
    return final_graph, type_condition
