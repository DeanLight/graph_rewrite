# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_lhs_parsing.ipynb.

# %% auto 0
__all__ = ['lhs_parser', 'cnt', 'lhsTransformer', 'collectTypeConstraints', 'parse_lhs']

# %% ../nbs/01_lhs_parsing.ipynb 5
lhs_parser = Lark(r"""
    %import common.NUMBER -> NATURAL_NUMBER 
    %import common.ESCAPED_STRING
    %import common.WS 
    %ignore WS

    NAMED_VERTEX: /[a-zA-Z0-9]+/ 
    ANONYMUS: "_"
    ATTR_NAME: /[a-zA-Z0-9]+/ 
    TYPE:  "int" | "string" | "bool" 
    VALUE: /[0-9a-zA-Z]/

    attribute: ATTR_NAME [":" TYPE] ["=" VALUE] 
    attributes: "\[" attribute ("," attribute)* "\]"

    multi_connection: "-" NATURAL_NUMBER "+" [attributes] "->" 
                    | "-" NATURAL_NUMBER [attributes] "->" 
    connection: "-" [attributes "-"] ">"
              | multi_connection
    
    index_vertex: NAMED_VERTEX "<" NATURAL_NUMBER ("," NATURAL_NUMBER)* ">"

    vertex: NAMED_VERTEX [attributes]
        | index_vertex [attributes]
        | ANONYMUS [attributes]

    pattern: vertex (connection vertex)*
    patterns: pattern (";" pattern)*
        
    """, parser="lalr", start='patterns' , debug=True)

# %% ../nbs/01_lhs_parsing.ipynb 9
import itertools
import copy
import networkx as nx

# %% ../nbs/01_lhs_parsing.ipynb 10
cnt:int = 0 # unique id for anonymous vertices
from lark import Tree, Transformer
class lhsTransformer(Transformer):
    def NATURAL_NUMBER(self, number):
        return int(number)
    
    def attribute(self, attr_name, _):
        return (attr_name, "default") # constraints are handled in other transformer.
    
    def attributes(self, *attributes: list):
        # return a packed list of the attribute names.
        attr_dict = {}
        for attribute in attributes:
            attr_dict[attribute[0]] = attribute[1]
        return attr_dict

    def multi_connection(self, number, attributes: dict): # +
        # renewed: return the list of attributes(strings), add a special attribute to denote number of duplications,
        #   and FALSE (indicating that the connection is not deterministic)
        attributes["$dup"] = number
        return (attributes, False)
    
    def multi_connection(self, number, attributes: dict): # no +
        # renewed: return the list of attributes(strings), add a special attribute to denote number of duplications,
        #   and TRUE (indicating that the connection is not deterministic)
        attributes["$dup"] = number
        return (attributes, True)

    def connection(self, multiconnection_params: tuple): #multiconnection
        # return the packed list of attributes received, num_duplications, is_deterministic
        return multiconnection_params

    def connection(self, *attributes): #
        # return the packed list of attributes received, num_duplications = 1, is_deterministic = True
        attributes["$dup"] = 1
        return (attributes, True)

    def ANONYMUS(self): #
        # return a dedicated name for anonymus (string), and an empty list.
        cnt += 1
        return ("$" + str(cnt), [])

    def index_vertex(self, main_name, *numbers):
        # return the main name of the vertex, and a list of the indices specified.
        return (main_name, numbers)
    
    def NAMED_VERTEX(self, name):
        # return the main name of the vertex, and an empty list.
        return (name, [])

    def vertex(self, vertex_tuple: tuple, attributes: dict):
        # return arguments
        name, indices_list = vertex_tuple
        new_name = ",".join(indices_list) # numbers are strings, no convertion needed.
        return (new_name, attributes)

    def pattern(self, vertex, *rest):
        # 1) unpack lists of vertices and connections.
        conn, vertices = rest[::2], rest[1::2]
        vertices.insert(0,vertex)
        # 2) create a networkX graph:
            # if there is a special attribute with TRUE, dumplicate the connection __number__ times.
        G = nx.Graph()

        # simplified vertion - ignore duplications
        G.add_nodes_from(vertices)
        edge_list = []
        for i,edge in enumerate(conn):
            edge_list.append((vertices[i], vertices[i+1], edge[0])) # ignore edge[1] - determinism flag

        # more complex vertion - duplications
        # create a recursive function that adds the vertices and edges, 
        # that calls itself by the number of duplications on each level.

    def patterns(self,):
        g = nx.Graph()
        pass

# %% ../nbs/01_lhs_parsing.ipynb 13
class collectTypeConstraints(Transformer):
    def attribute(self, attr_name, type, value):
        # return a mapping from attr_name - > required type and value
        pass

    def attributes(self, *attributes):
        # return a packed list of the attribute mappings.
        pass

    def vertex(self, name, indices_list, attributes_list):
        # same as lhsTransformer
        pass

    def pattern(self, vertex, *connections_to_vertex):
        # return arguments
        pass

    def patterns(self, *patterns):
        # unpack lists of vertices and connections.
        def typeCondition(Match):
            # for every vertex in vertex list:
                # create full_vertex_name by the attached indices list
                # for every attr, type, name required for the vertex:
                    # constructor = getName(type) - get the constructor for the type
                    # 1) check that the required type and value match together.
                    # try:
                    #     instance = constructor(value)
                    # Except:
                        # flag = False: value does not match the type.

                    # 2) check that the value constraint holds
                    # if getattr(instance, __eq__) == None:
                        # flag = False. the type must implement __eq__
                    # if not (instance == match[full_vertex_name][attr])

                    # no need to check the type constraint(?), if the value fits. (python)

            # TODO: perform the same iterations in the connections list.

            #return flag and condition(Match)
            pass

        return typeCondition #sent as a module output and replaces condition.
        pass

# %% ../nbs/01_lhs_parsing.ipynb 15
def parse_lhs(lhs: string):
    tree = lhs_parser.parse(lhs)
    final_g = lhsTransformer().transform(tree) #networkx graph
    return final_g
