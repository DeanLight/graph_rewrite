# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_lhs_parsing.ipynb.

# %% auto 0
__all__ = ['cnt', 'lhsTransformer', 'collectTypeConstraints', 'lhs_to_graph']

# %% ../nbs/01_lhs_parsing.ipynb 5
# lhs_parser = Lark(r"""
#     %import common.NUMBER -> NATURAL_NUMBER 
#     %import common.ESCAPED_STRING
#     %import common.WS 
#     %ignore WS

#     NAMED_VERTEX: /[a-zA-Z0-9]+/
#     ANONYMUS: "_"
#     ATTR_NAME: /[a-zA-Z0-9]+/
#     TYPE:  "int" | "string" | "bool"
#     VALUE: /[0-9a-zA-Z]/

#     attribute: ATTR_NAME [":" TYPE] ["=" VALUE]
#     attributes: "[" attribute ("," attribute)* "]"

#     multi_connection: "-" NATURAL_NUMBER "+" [attributes] "->" 
#                     | "-" NATURAL_NUMBER [attributes] "->" 
#     connection: "-" [attributes "-"] ">"
#               | multi_connection
    
#     index_vertex: NAMED_VERTEX "<" NATURAL_NUMBER ("," NATURAL_NUMBER)* ">"

#     vertex: NAMED_VERTEX [attributes]
#         | index_vertex [attributes]
#         | ANONYMUS [attributes]

#     pattern: vertex (connection vertex)*
#     patterns: pattern (";" pattern)*
        
#     """, parser="lalr", start='patterns' , debug=True)


# %% ../nbs/01_lhs_parsing.ipynb 8
import itertools
import copy
import networkx as nx

# %% ../nbs/01_lhs_parsing.ipynb 9
cnt:int = 0 # unique id for anonymous vertices
from lark import Tree, Transformer
class lhsTransformer(Transformer):
    def NATURAL_NUMBER(self, number):
        return int(number)
    
    def attribute(self, args): #(attr_name, *rest):
        attr_name = args[0]
        return (attr_name, "default") # constraints are handled in other transformer.
    
    def attributes(self, attributes): # a list of tuples 
        # return a packed list of the attribute names.
        attr_dict = {}
        for attribute in attributes:
            # print(attribute)
            attr_dict[str(attribute[0])] = attribute[1]
        return attr_dict

    def multi_connection(self, args): # +
        # return the list of attributes(strings), add a special attribute to denote number of duplications.
        #   for "-+->" implementation also return FALSE if "+" is parsed (indicating that the connection is not deterministic)
        number, attributes = args
        attributes["$dup"] = number
        return attributes

    # def connection(self, multiconnection_params: tuple): #multiconnection
    #     # return the packed list of attributes received, num_duplications, is_deterministic
    #     return multiconnection_params

    # def connection(self, attributes): # a dict of attributes
    #     # return the packed list of attributes received, num_duplications = 1, is_deterministic = True
    #     attributes["$dup"] = 1
    #     return (attributes, True)

    def ANONYMUS(self): #
        # return a dedicated name for anonymus (string), and an empty list.
        cnt += 1
        return ("$" + str(cnt), [])

    def index_vertex(self, args):
        # return the main name of the vertex, and a list of the indices specified.
        main_name_tup, *numbers = args #numbers is a list
        # print(main_name_tup)
        # print(numbers)
        return (main_name_tup[0], list(numbers))
    
    def NAMED_VERTEX(self, name):
        # return the main name of the vertex, and an empty list.
        return (name, [])

    def vertex(self, args): # (vertex_tuple: tuple, attributes: dict = {})
        # return arguments
        vertex_tuple, *attributes = args # attributes is a empty list/ a list containing a dict
        name, indices_list = vertex_tuple 
        if indices_list == None:
            indices_list = []
        indices = ",".join([str(num) for num in indices_list])
        new_name = name + "<"
        new_name = new_name + indices + ">" # numbers are strings, no convertion needed.
        if len(attributes) == 0:
            return (new_name, {})
        return (new_name, attributes[0])

    def pattern(self, args):
        # 1) unpack lists of vertices and connections.
        vertex, *rest = args
        conn, vertices = list(rest)[::2], list(rest)[1::2]
        vertices.insert(0,vertex)
        print(vertices)
        print(conn)
        # 2) create a networkX graph:
            # if there is a special attribute with TRUE, dumplicate the connection __number__ times.
        G = nx.DiGraph()

        # simplified vertion - ignore duplications
        G.add_nodes_from(vertices)
        edge_list = []
        for i,edge in enumerate(conn):
            edge_list.append((vertices[i], vertices[i+1], edge[0])) # ignore edge[1] - determinism flag. edge[0] is attributes.

        # more complex vertion - duplications
        # create a recursive function that adds the vertices and edges, 
        # that calls itself by the number of duplications on each level.
        G.add_edges_from(edge_list)
        return G

    # def patterns(self, g, *graphs):
    #     patterns = list(graphs)
    #     patterns.insert(0,g)
    #     # unite all the patterns into a single graph
    #     G = nx.DiGraph()

    #     combined_attributes = dict() # dict of dicts (node_name -> attribute -> value)
    #     new_nodes = []
    #     new_edges = []
    #     for graph in patterns:
    #         for node in graph.nodes:
    #             combined_attributes[node] = combined_attributes[node] | graph.nodes.data()[node]
    #             new_nodes.append(node) #unite the dicts for each
    #         for edge in graph.edges:
    #             combined_attributes[edge[0]+","+edge[1]] = combined_attributes[edge[0]+","+edge[1]] | graph.edges[edge[0],edge[1]]
    #             new_edges.append(edge)

    #     G.add_nodes_from([(node, combined_attributes[node]) for node in new_nodes])
    #     G.add_edges_from([(node1, node2, combined_attributes[node1+","+node2]) for (node1,node2) in new_edges])
    #     return G

# %% ../nbs/01_lhs_parsing.ipynb 11
class collectTypeConstraints(Transformer):
    def attribute(self, attr_name, type, value):
        # return a mapping from attr_name - > required type and value
        pass

    def attributes(self, *attributes):
        # return a packed list of the attribute mappings.
        pass

    def vertex(self, name, indices_list, attributes_list):
        # same as lhsTransformer
        pass

    def pattern(self, vertex, *connections_to_vertex):
        # return arguments
        pass

    def patterns(self, *patterns):
        # unpack lists of vertices and connections.
        def typeCondition(Match):
            # for every vertex in vertex list:
                # create full_vertex_name by the attached indices list
                # for every attr, type, name required for the vertex:
                    # constructor = getName(type) - get the constructor for the type
                    # 1) check that the required type and value match together.
                    # try:
                    #     instance = constructor(value)
                    # Except:
                        # flag = False: value does not match the type.

                    # 2) check that the value constraint holds
                    # if getattr(instance, __eq__) == None:
                        # flag = False. the type must implement __eq__
                    # if not (instance == match[full_vertex_name][attr])

                    # no need to check the type constraint(?), if the value fits. (python)

            # TODO: perform the same iterations in the connections list.

            #return flag and condition(Match)
            pass

        return typeCondition #sent as a module output and replaces condition.
        pass

# %% ../nbs/01_lhs_parsing.ipynb 13
def lhs_to_graph(lhs):
    tree = lhs_parser.parse(lhs)
    final_g = lhsTransformer().transform(tree) #networkx graph
    return final_g
