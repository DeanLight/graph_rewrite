# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_rules.ipynb.

# %% auto 0
__all__ = ['exceptions', 'Rule']

# %% ../nbs/05_rules.ipynb 4
from networkx import DiGraph
from .match_class import *
from typing import *
from .core import GraphRewriteException, NodeName, EdgeName, _create_graph, _plot_graph

# %% ../nbs/05_rules.ipynb 6
exceptions = {
    "clone_non_existing": lambda p_node, lhs_node: f"Node {p_node} clones an non-existing node {lhs_node}.",
    "clone_illegal_id": lambda p_node, copy_num: f"Node {p_node} clone id {copy_num} is illegal.",
    "p_bad_format": lambda p_node: f"Node {p_node} has a bad formatted name.",
    "p_not_in_lhs": lambda p_node: f"Node {p_node} in P does not exist in LHS.",
    "rhs_illegal_name": lambda rhs_node: f"Node {rhs_node} merges at least one non-existing P node.",
    "rhs_not_in_p": lambda p_node: f"Node {p_node} in P does not exist in RHS, nor merges into an RHS node.",
    "add_attrs_in_p_node": lambda p_node: f"P node {p_node} cannot add attributes.",
    "add_attrs_in_p_edge": lambda s_copy, t_copy: f"P edge ({s_copy},{t_copy}) cannot add attributes.",
    "remove_attrs_in_rhs_node": lambda rhs_node: f"RHS node {rhs_node} cannot remove attributes.",
    "remove_attrs_in_rhs_edge": lambda s, t: f"RHS edge ({s},{t}) cannot remove attributes.",
    "attrs_in_cloned_node": lambda p_node: f"Cloned node {p_node} in P should not explicitly mention attributes",
    "attrs_in_cloned_edge": lambda s_copy, t_copy: f"Cloned edge ({s_copy},{t_copy}) in P should not explicitly mention attributes"
}

# %% ../nbs/05_rules.ipynb 7
class Rule:
    global exceptions
    """A transformation rule, defined by 1-3 graphs:
    - LHS - defines the pattern to search for in the graph.
    - P - defines what parts to preserve (and also defines clones).
    - RHS - defines what parts to add (and also defines merges).
    """
    def __init__(self, lhs: DiGraph, p: DiGraph = None, rhs: DiGraph = None):
        self.lhs = lhs
        self.p = p if p else self.lhs.copy()
        self.rhs = rhs if rhs else self.p.copy()
        
        self._p_to_lhs, self._p_to_rhs = {}, {}
        self._merge_sym, self._clone_sym = '&', '*'
        self._create_p_lhs_hom()
        self._create_p_rhs_hom()

        self._rev_p_lhs = self._reversed_dictionary(self._p_to_lhs)
        self._rev_p_rhs = self._reversed_dictionary(self._p_to_rhs)
        self._validate_rule()

    # Utils
    def _create_p_lhs_hom(self):
        """Construct the homomorphism from P to LHS based on the rule.
        Handles cloned nodes.
        """
        for p_node in self.p.nodes():
            if self._clone_sym in str(p_node):
                if len(str(p_node).split(self._clone_sym)) == 2:
                    lhs_node, copy_num = str(p_node).split(self._clone_sym)
                    if lhs_node not in self.lhs.nodes():
                        raise GraphRewriteException(exceptions["clone_non_existing"](p_node, lhs_node))
                    elif not copy_num.isnumeric():
                        raise GraphRewriteException(exceptions["clone_illegal_id"](p_node, copy_num))
                    else:
                        self._p_to_lhs[p_node] = lhs_node
                else:
                    raise GraphRewriteException(exceptions["p_bad_format"](p_node))
            elif p_node in self.lhs.nodes():
                self._p_to_lhs[p_node] = p_node
            else:
                raise GraphRewriteException(exceptions["p_not_in_lhs"](p_node))

    def _create_p_rhs_hom(self):
        """Construct the homomorphism from P to RHS based on the rule.
        Handles merged nodes.
        """
        for rhs_node in self.rhs.nodes():
            if self._merge_sym in str(rhs_node):
                if len(str(rhs_node).split(self._merge_sym)) > 1:
                    p_nodes = str(rhs_node).split(self._merge_sym)
                    if all([p_node in self.p.nodes() for p_node in p_nodes]):
                        for p_node in p_nodes:
                            self._p_to_rhs[p_node] = rhs_node
                    else:
                        raise GraphRewriteException(exceptions["rhs_illegal_name"](rhs_node))
        for p_node in self.p.nodes():
            if p_node not in self._p_to_rhs.keys():
                if p_node in self.rhs.nodes():
                    self._p_to_rhs[p_node] = p_node
                else:
                    raise GraphRewriteException(exceptions["rhs_not_in_p"](p_node))

    def _reversed_dictionary(self, dictionary: dict) -> dict[Any, set]:
        """Given a dictionary, return a dictionary which maps every
        value from the original dictionary to the set of keys 
        that are mapped to it.

        E.g., for {1: 'a', 2: 'a', 3: 'b'}, the reversing function
        returns {'a': {1,2}, 'b': {3}}.

        Args:
            dictionary (dict): A dictionary to reverse

        Returns:
            dict[Any, set]: A reversed dictionary as described
        """
        rev_dict: dict[Any, set] = {}
        for key, value in dictionary.items():
            if value not in rev_dict:
                rev_dict[value] = set()
            rev_dict[value].add(key)
        return rev_dict

    def _keys_from_val(self, dictionary: dict[Any, set], key) -> set:
        return dictionary[key] if key in dictionary else set()

    def _dict_key_difference(self, dict1: dict, dict2: dict) -> set:
        """Given two dictionaries, find all keys that appear in the first dictionary
        but not in the second one.

        Args:
            dict1 (dict): A dictionary
            dict2 (dict): A dictionary

        Returns:
            set: A set of all keys that appear in the first dictionary but not in the second.
        """
        return set(dict1.keys()) - set(dict2.keys())

    def _merge_dictionaries(self, dict1: dict, dict2: dict) -> dict:
        merged = {}
        for key in dict1.keys():
            if key in dict2.keys():
                merged[key] = dict2[key] # TODO
            else:
                merged[key] = dict1[key]
        for key in dict2.keys():
            if key not in dict1.keys():
                merged[key] = dict2[key]
        return merged

    def _validate_lhs_p(self):
        # Nodes in P do NOT add attributes that aren't in the corresponding LHS node(s).
        for node_lhs in self.lhs.nodes():
            lhs_attrs = set(self.lhs.nodes(data=True)[node_lhs].keys())
            p_copies = self._keys_from_val(self._rev_p_lhs, node_lhs)
            for node_p in p_copies:
                p_attrs = set(self.p.nodes(data=True)[node_p].keys())
                if not p_attrs.issubset(lhs_attrs):
                    raise GraphRewriteException(exceptions["add_attrs_in_p_node"](node_p))
        
        # Edges in P do NOT add attributes that aren't in the corresponding LHS edge(s).
        for s, t in self.lhs.edges():
            rhs_attrs = set(self.lhs.get_edge_data(s, t).keys())
            s_copies, t_copies = self._keys_from_val(self._rev_p_lhs, s), self._keys_from_val(self._rev_p_lhs, t)
            for s_copy in s_copies:
                for t_copy in t_copies:
                    # For each "clone of edge (s, t)" that is in P
                    if (s_copy, t_copy) in self.p.edges():
                        p_attrs = set(self.p.get_edge_data(s_copy, t_copy).keys())
                        if not p_attrs.issubset(rhs_attrs):
                            raise GraphRewriteException(exceptions["add_attrs_in_p_edge"](s_copy, t_copy))

    def _validate_rhs_p(self):
        # Nodes in RHS do NOT remove attributes that are in the corresponding P node(s).
        # Note that we ignore merged nodes here (which follow this rule automatically).
        for node_rhs in self.rhs.nodes():
            if node_rhs not in self.nodes_to_merge().keys():
                rhs_attrs = set(self.rhs.nodes(data=True)[node_rhs].keys())
                p_origins = self._keys_from_val(self._rev_p_rhs, node_rhs)
                for node_p in p_origins:
                    p_attrs = set(self.p.nodes(data=True)[node_p].keys())
                    if not p_attrs.issubset(rhs_attrs):
                        raise GraphRewriteException(exceptions["remove_attrs_in_rhs_node"](node_rhs))
        
        # Edges in RHS do NOT remove attributes that are in the corresponding P edge(s).
        # Note that we ignore edges created by a merge here (they follow this rule automatically).
        for s, t in self.rhs.edges():
            if s not in self.nodes_to_merge().keys() and t not in self.nodes_to_merge().keys():
                rhs_attrs = set(self.rhs.get_edge_data(s, t).keys())
                s_origins, t_origins = self._keys_from_val(self._rev_p_rhs, s), self._keys_from_val(self._rev_p_rhs, t)
                for s_origin in s_origins:
                    for t_origin in t_origins:
                        if (s_origin, t_origin) in self.p.edges():
                            origin_attrs = set(self.p.get_edge_data(s_origin, t_origin).keys())
                            if not origin_attrs.issubset(rhs_attrs):
                                raise GraphRewriteException(exceptions["remove_attrs_in_rhs_edge"](s,t))

    def _validate_rule(self):
        self._validate_lhs_p()
        self._validate_rhs_p()
        
        clones = {item for clones_list in self.nodes_to_clone().values() for item in clones_list}
        # validate cloned nodes in P have no attributes mentioned (all attributes are copied automatically)
        for clone in clones:
            if self.p.nodes(data=True)[clone] != {}:
                raise GraphRewriteException(exceptions["attrs_in_cloned_node"](clone))
        
        # validate cloned edges in P (edges with cloned endpoint) have no attributes mentioned
        for s, t, attrs in self.p.edges(data=True):
            if (s in clones or t in clones) and attrs != {}:
                raise GraphRewriteException(exceptions["attrs_in_cloned_edge"](s, t))

    def _merge_node_attrs(self, rhs_node: NodeName, p_origins: list[NodeName]) -> dict:
        """Given a node in RHS that is a copy / a merge of one or more nodes in P,
        and the P nodes which it copies / merges, returns the dictionary of attributes
        in the new merged node in RHS.

        Args:
            rhs_node (NodeName): A node in RHS
            p_origins (list[NodeName]): A list of P nodes which rhs_node merges.

        Returns:
            dict: A dictionary of attributes (keys and values) of the merged rhs node.
        """
        merge_rhs_attrs = {}
        for p_origin in p_origins:
            new_rhs_attrs = {k: self.rhs.nodes(data=True)[rhs_node][k] for k in \
                                self._dict_key_difference(self.rhs.nodes(data=True)[rhs_node], 
                                                          self.p.nodes(data=True)[p_origin])}
            merge_rhs_attrs = self._merge_dictionaries(merge_rhs_attrs, new_rhs_attrs)
        return merge_rhs_attrs

    def _merge_edge_attrs(self, rhs_edge: EdgeName, s_origins: list[NodeName], t_origins: list[NodeName]) -> dict:
        merge_rhs_attrs = {}
        for s_origin in s_origins:
            for t_origin in t_origins:
                if (s_origin, t_origin) in self.p.edges():
                    new_rhs_attrs = {k: self.rhs.get_edge_data(*rhs_edge)[k] for k in \
                                        self._dict_key_difference(self.rhs.get_edge_data(*rhs_edge), 
                                                                  self.p.get_edge_data(s_origin, t_origin))}
                    merge_rhs_attrs = self._merge_dictionaries(merge_rhs_attrs, new_rhs_attrs)
        return merge_rhs_attrs

    # The following functions are presented in the order of transformation.
    def nodes_to_clone(self) -> dict[NodeName, set[NodeName]]:
        """Find all LHS nodes that should be cloned in P, and for each node, find all its P clones.

        Returns:
            dict[NodeName, set[NodeName]]:
                A dictionary which maps each cloned node in LHS to a set
                of all nodes in P which are its clones.
        """

        # Find all LHS nodes which are mapped by more than one node in P (in the P->LHS Hom.)
        return {lhs_node: self._rev_p_lhs[lhs_node] for lhs_node in self.lhs.nodes() \
                            if len(self._keys_from_val(self._rev_p_lhs, lhs_node)) > 1}

    def nodes_to_remove(self) -> set[NodeName]:
        """Find all LHS nodes that should be removed.

        Returns:
            set[NodeName]: Nodes in LHS which should be removed.
        """

        # Find all LHS nodes which are not mapped by any node in P (in the P->LHS Hom.)
        return {lhs_node for lhs_node in self.lhs.nodes() if len(self._keys_from_val(self._rev_p_lhs, lhs_node)) == 0}

    def edges_to_remove(self) -> set[EdgeName]:
        """Find all LHS edges that should be removed.

        Note: Does not include edges which one of their endpoints was removed by the rule,
        as during transformation, we begin by removing all removed nodes along with the connected edges.

        Returns:
            set[EdgeName]: Edges in LHS which should be removed.
        """
        edges_to_remove = set()
        for s, t in self.lhs.edges():
            # If one of the edge endpoints was removed, the edge was removed automatically so we skip it here
            if s not in self.nodes_to_remove() and t not in self.nodes_to_remove():
                s_copies, t_copies = self._keys_from_val(self._rev_p_lhs, s), self._keys_from_val(self._rev_p_lhs, t)
                for s_copy in s_copies:
                    for t_copy in t_copies:
                        # For each "clone of edge (s,t)" that shouldn't be in P, remove it
                        if (s_copy, t_copy) not in self.p.edges():
                            edges_to_remove.add((s_copy, t_copy))
        return edges_to_remove

    def node_attrs_to_remove(self) -> dict[NodeName, set]:
        """For each P node, find all attributes of its corresponding LHS node
        which should be removed from it in P.

        Returns:
            dict[NodeName, set]: A dictionary from P nodes to attributes that should be
                removed from their corresponding LHS nodes.
        """
        attrs_to_remove = {}
        for node_lhs in self.lhs.nodes():
            if node_lhs not in self.nodes_to_clone().keys(): # cloned nodes do not remove attrs
                p_copies = self._keys_from_val(self._rev_p_lhs, node_lhs)
                for node_p in p_copies:
                    # Find all attributes that are in the LHS node but not in the new P node
                    diff_attrs = self._dict_key_difference(
                        self.lhs.nodes(data=True)[node_lhs],
                        self.p.nodes(data=True)[node_p]
                    )
                    if len(diff_attrs) != 0:
                        # Remove all such attributes from the P node
                        attrs_to_remove[node_p] = diff_attrs
        return attrs_to_remove

    def edge_attrs_to_remove(self) -> dict[EdgeName, set]:
        """For each P edge, find all attributes of its corresponding LHS edge
        which should be removed from it in P.

        Returns:
            dict[EdgeName, set]: A dictionary from P edges to attributes that should be
                removed from their corresponding LHS edges.
        """
        attrs_to_remove = {}
        for s, t in self.lhs.edges():
            s_copies, t_copies = self._keys_from_val(self._rev_p_lhs, s), self._keys_from_val(self._rev_p_lhs, t)
            for s_copy in s_copies:
                for t_copy in t_copies:
                    # For each "clone of edge (s, t)" that is in P
                    if (s_copy, t_copy) in self.p.edges():
                        # Find all attributes that are in the original LHS edge but not in the new one in P
                        diff_attrs = self._dict_key_difference(
                            self.lhs.get_edge_data(s, t),
                            self.p.get_edge_data(s_copy, t_copy),
                        )
                        if len(diff_attrs) != 0:
                            # Remove all such attributes
                            attrs_to_remove[(s_copy, t_copy)] = diff_attrs
        return attrs_to_remove

    def nodes_to_merge(self) -> dict[NodeName, set[NodeName]]:
        """Find all RHS nodes which are a merge of nodes in P, and for each node, find all P nodes that merge into it.

        Returns:
            dict[NodeName, set[NodeName]]: 
                A dictionary which maps each node in RHS that is a merge of P nodes,
                to a set of nodes in P which it merges.
        """

        # Find all RHS nodes that are mapped by more than one node in P (in the P->RHS Hom.)
        return {rhs_node: self._rev_p_rhs[rhs_node] for rhs_node in self.rhs.nodes() \
                            if len(self._keys_from_val(self._rev_p_rhs, rhs_node)) > 1}

    def nodes_to_add(self) -> set[NodeName]:
        """Find all RHS nodes which should be added.

        Note: Does not include nodes in RHS that are created as a merge of P nodes.

        Returns:
            set[NodeName]: Nodes which should be added to RHS.
        """

        # Find all RHS nodes which are not mapped by any node in P (in the P->RHS Hom.)
        return {rhs_node for rhs_node in self.rhs.nodes() if len(self._keys_from_val(self._rev_p_rhs, rhs_node)) == 0}

    def edges_to_add(self) -> set[EdgeName]:
        """Find all RHS edges that should be added. 

        Note: Does not include edges added to merged nodes.

        Returns:
            set[EdgeName]: Edges which should be added to RHS.
        """
        edges_to_add = set()
        for s, t in self.rhs.edges():
            # New edges from at least one new node (not including merged nodes)
            if s in self.nodes_to_add() or t in self.nodes_to_add():
                edges_to_add.add((s,t)) # surely a new edge
            else:
                s_origins, t_origins = self._keys_from_val(self._rev_p_rhs, s), self._keys_from_val(self._rev_p_rhs, t)
                # New edges from existing P nodes
                if all([(s_origin, t_origin) not in self.p.edges() for s_origin in s_origins for t_origin in t_origins]):
                    edges_to_add.add((s,t))
        return edges_to_add

    def node_attrs_to_add(self) -> dict[NodeName, dict]:
        """For each RHS node, find all attributes (and values) of its corresponding P node(s)
        which should be added to the RHS node.
        
        Returns:
            dict[NodeName, dict]: A dictionary that maps RHS nodes to their added attributes and values.
        """
        attrs_to_add = {}
        for node_rhs in self.rhs.nodes():
            if node_rhs in self.nodes_to_add():
                rhs_attrs = self.rhs.nodes(data=True)[node_rhs]
                if len(rhs_attrs) != 0:
                    attrs_to_add[node_rhs] = rhs_attrs
            else:
                p_origins = self._keys_from_val(self._rev_p_rhs, node_rhs)
                merged_p_attrs = self._merge_node_attrs(node_rhs, p_origins)
                if len(merged_p_attrs) != 0:
                    attrs_to_add[node_rhs] = merged_p_attrs
        return attrs_to_add

    def edge_attrs_to_add(self) -> dict[EdgeName, dict]:
        """For each RHS edge, find all attributes (and values) of its corresponding P edge(s)
        which should be added to the RHS edge.

        Returns:
            dict[EdgeName, dict]: A dictionary that maps RHS edges to their added attributes and values.
        """
        attrs_to_add = {}
        for s, t in self.rhs.edges():
            if s in self.nodes_to_add() or t in self.nodes_to_add():
                rhs_attrs = self.rhs.get_edge_data(s, t)
                if len(rhs_attrs) != 0:
                    attrs_to_add[(s, t)] = rhs_attrs
            else:
                s_origins, t_origins = self._keys_from_val(self._rev_p_rhs, s), self._keys_from_val(self._rev_p_rhs, t)
                merged_p_attrs = self._merge_edge_attrs((s, t), s_origins, t_origins)
                if len(merged_p_attrs) != 0:
                    attrs_to_add[(s, t)] = merged_p_attrs
        return attrs_to_add

