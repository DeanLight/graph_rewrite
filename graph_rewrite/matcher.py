# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_matcher.ipynb.

# %% auto 0
__all__ = ['FilterFunc', 'Constant']

# %% ../nbs/03_matcher.ipynb 5
from typing import *
from networkx import DiGraph
from networkx.algorithms import isomorphism # check subgraph's isom.
from .core import NodeName, _create_graph, draw
from .lhs import lhs_to_graph
from .match_class import Match, mapping_to_match, is_anonymous_node,draw_match
from itertools import product, permutations
from typing import Tuple, Iterator

# %% ../nbs/03_matcher.ipynb 8
# TODO: Ensure we separate between constant attributes and existence checks (constants).
# a[id] -> existence check (can be checked before combinatorics)
# a[id=Constant(3)] -> constant value check (can be checked before combinatorics)

# TODO: Email Dean regarding the parser ability to support constant values in the pattern graph - it is currently not supported, and so all constant values will still
#  result in a None value in the pattern graph.
class Constant:
    def __init__(self, value):
        self.value = value


def _attributes_match(pattern_attrs: dict, input_attrs: dict) -> bool:
    """
    Check if the input attributes match the pattern attributes.

    This function supports both:
    - Existence checks (ensures that required attributes exist).
    - Constant value checks (ensures that constant values match).

    Args:
        pattern_attrs (dict): Attributes of the pattern (node or edge).
        input_attrs (dict): Attributes of the input (node or edge).

    Returns:
        bool: True if the input attributes match the pattern attributes, False otherwise.
    """
    for attr_name, attr_value in pattern_attrs.items():
        if attr_name not in input_attrs:  # If the attribute does not exist, return False
            return False
        
        if attr_value is None: # If the attribute exists, but the value is None, continue to the next attribute
            continue

        # TODO: This is not supported yet due to the parser not supporting constant values in the pattern graph - we will never reach this point, and it is implemented for future use, 
        # once the parser supports it.
        if isinstance(attr_value, Constant):  # If the attribute exists, and the value is a constant, check if the value matches
            if input_attrs[attr_name] != attr_value.value:
                return False

    return True

# %% ../nbs/03_matcher.ipynb 10
def _find_input_nodes_candidates(pattern_node: NodeName, pattern: DiGraph, input_graph: DiGraph) -> set[NodeName]:
    """
    Given a pattern node and an input graph, return a set of input graph nodes that:
    - Contain the required attributes of the pattern node, including constant value checks (if specified) and existence checks (if no value is specified / no constant value).
    - Have at least one edge with matching attributes for each edge of the pattern node that has attributes specified.

    Args:
        pattern_node (NodeName): The pattern node.
        pattern (DiGraph): The pattern graph.
        input_graph (DiGraph): The input graph.

    Returns:
        set[NodeName]: A set of input graph nodes that match the required attributes and have at least one matching edge.
    """

    pattern_node_attrs = pattern.nodes[pattern_node]

    if "_id" in pattern_node_attrs:
        input_node_id = pattern_node_attrs.pop("_id")
        input_nodes_to_check = [input_node_id]
    else:
        input_nodes_to_check = list(input_graph.nodes)

    # Filter nodes by attributes first
    candidate_nodes = {
        input_node
        for input_node in input_nodes_to_check
        if _attributes_match(pattern_node_attrs, input_graph.nodes[input_node])
    }

    return candidate_nodes

# %% ../nbs/03_matcher.ipynb 11
# Helper function to check if an input edge matches the pattern edge
def _is_valid_edge_candidate(input_graph: DiGraph, pattern_edge_attrs: dict, 
                   src_candidate: NodeName, dst_candidate: NodeName, 
                   src_pattern_node: NodeName, dst_pattern_node: NodeName) -> bool:
    """
    Check if an edge between two input nodes matches the pattern edge and attributes.

    Args:
        input_graph (DiGraph): The input graph.
        pattern_edge_attrs (dict): Attributes of the pattern edge to match.
        src_candidate (NodeName): The source candidate node in the input graph.
        dst_candidate (NodeName): The destination candidate node in the input graph.
        src_pattern_node (NodeName): The source pattern node.
        dst_pattern_node (NodeName): The destination pattern node.

    Returns:
        bool: True if the input edge is valid, False otherwise.
    """
    if (src_candidate, dst_candidate) not in input_graph.edges:
        return False

    input_edge_attrs = input_graph.get_edge_data(src_candidate, dst_candidate, default={})
    if not _attributes_match(pattern_edge_attrs, input_edge_attrs):
        return False

    # Special case: If the source and destination are the same node in the pattern,
    # ensure the source and destination candidates are also the same in the input graph
    if src_pattern_node == dst_pattern_node and src_candidate != dst_candidate:
        return False

    return True

# %% ../nbs/03_matcher.ipynb 12
def _filter_edge_candidates(input_graph: DiGraph, pattern: DiGraph, 
                            src_pattern_node: NodeName, dst_pattern_node: NodeName, 
                            src_candidates: Set[NodeName], dst_candidates: Set[NodeName]) -> Set[Tuple[NodeName, NodeName]]:
    """
    Filter the input node candidates for two pattern nodes by checking if the edges between them in the input graph exist
    and match the pattern edge attributes.

    Args:
        input_graph (DiGraph): The input graph.
        pattern (DiGraph): The pattern graph (provides the edge attributes).
        src_pattern_node (NodeName): The source pattern node.
        dst_pattern_node (NodeName): The destination pattern node.
        src_candidates (Set[NodeName]): Current candidates for the source pattern node.
        dst_candidates (Set[NodeName]): Current candidates for the destination pattern node.

    Returns:
        Set[Tuple[NodeName, NodeName]]: A set of valid candidate edge assignments (source, destination).
    """

    pattern_edge_attrs = pattern.get_edge_data(src_pattern_node, dst_pattern_node, default={})

    valid_edge_candidates = {
        (src_candidate, dst_candidate)
        for src_candidate, dst_candidate in product(src_candidates, dst_candidates)
        if _is_valid_edge_candidate(input_graph, pattern_edge_attrs, src_candidate, dst_candidate, src_pattern_node, dst_pattern_node)
    }

    return valid_edge_candidates


# %% ../nbs/03_matcher.ipynb 14
def _extend_assignments_with_nodes(pattern_nodes_mapped_to_candidates, partial_assignments: List[Dict[NodeName, NodeName]], input_graph: DiGraph) -> List[Dict[NodeName, NodeName]]:
    """
    Extend the partial assignments with nodes that have not been assigned yet, ensuring that each input node is only
    assigned once across the assignment, while respecting the filtered candidates for each pattern node.

    Args:
        pattern_nodes_mapped_to_candidates (Dict[NodeName, Set[NodeName]]): Dictionary mapping each unassigned pattern node 
                                                                            to its set of candidate input nodes.
        partial_assignments (List[Dict[NodeName, NodeName]]): List of current partial assignments.
        input_graph (DiGraph): The input graph.

    Returns:
        List[Dict[NodeName, NodeName]]: The partial assignments extended with nodes.
    """
    extended_assignments = []

    for partial_assignment in partial_assignments:
        unused_input_nodes = set(input_graph.nodes) - set(partial_assignment.values())
        filtered_candidates = {}
        for pattern_node, candidates in pattern_nodes_mapped_to_candidates.items():
            filtered_candidates[pattern_node] = candidates & unused_input_nodes

        current_assignments = [partial_assignment]

        # Iterate over each unassigned pattern node and extand the current partial_assignment to multiple partial assignments
        # where each one has a different candidate for this node
        for pattern_node in filtered_candidates.keys():
            new_assignments = []
            for assignment in current_assignments:
                # Ensure uniqueness by finding unused candidates for the current node
                unused_candidates = unused_input_nodes - set(assignment.values())
                possible_candidates = filtered_candidates[pattern_node] & unused_candidates
                # Extend assignment with all possible candidates
                for candidate in possible_candidates:
                    new_assignment = assignment.copy()
                    new_assignment[pattern_node] = candidate
                    new_assignments.append(new_assignment)
            current_assignments = new_assignments

        # Add the extended assignments for this partial assignment
        extended_assignments.extend(current_assignments)

    return extended_assignments

# %% ../nbs/03_matcher.ipynb 15
def _extend_assignments_with_edges(pattern_edges, partial_assignments, pattern, graph, is_self_loop=False):
    """
    Extend the partial assignments with valid edge candidates.

    Args:
        pattern_edges: The edges of the pattern graph.
        partial_assignments: The current partial assignments.
        pattern: The pattern graph.
        graph: The input graph.
        is_self_loop: Whether the pattern edge is a self-loop or not.

    Returns:
        List[Dict[NodeName, NodeName]]: A list of extended assignments.

    """
    edge_candidates = {}

    if is_self_loop:
        src_pattern_node, dst_pattern_node = pattern_edges[0]
        src_candidates = _find_input_nodes_candidates(src_pattern_node, pattern, graph)
        dst_candidates = src_candidates  # For self-loops, src and dst candidates are the same
    else:
        for src_pattern_node, dst_pattern_node in pattern_edges:
            src_candidates = _find_input_nodes_candidates(src_pattern_node, pattern, graph)
            dst_candidates = _find_input_nodes_candidates(dst_pattern_node, pattern, graph)
        
        edge_candidates[(src_pattern_node, dst_pattern_node)] = _filter_edge_candidates(
            graph, pattern, src_pattern_node, dst_pattern_node, src_candidates, dst_candidates)

    # Prepare a new list of assignments to avoid modifying the list during iteration
    new_partial_assignments = []

    # Extend assignments by iterating over valid edge candidates
    for (src_pattern_node, dst_pattern_node) in edge_candidates.keys():        
        for partial_assignment in partial_assignments:
            partial_assignment_extensions = []
            for src_candidate, dst_candidate in edge_candidates[(src_pattern_node, dst_pattern_node)]:
                extended_assignment = _try_extending_assignment_with_edge_candidate(
                    src_candidate, dst_candidate, partial_assignment, src_pattern_node, dst_pattern_node)
                
                if extended_assignment is not None and extended_assignment not in partial_assignment_extensions:
                    partial_assignment_extensions.append(extended_assignment)
            
            if partial_assignment_extensions:  # Only add assignments that could be extended
                new_partial_assignments.extend(partial_assignment_extensions)

    # Return the newly created assignments with edges
    return new_partial_assignments

#| export
def _try_extending_assignment_with_edge_candidate(src_candidate: NodeName, dst_candidate: NodeName, partial_assignment: Dict[NodeName, NodeName], 
                                            src_pattern_node: NodeName, dst_pattern_node: NodeName) -> Optional[Dict[NodeName, NodeName]]:
    """
    Extend the current partial assignment by adding the given src and dst candidates, if possible.

    Args:
        src_candidate: The candidate for the source pattern node.
        dst_candidate: The candidate for the destination pattern node.
        partial_assignment: The current partial assignment being considered.
        src_pattern_node: The source pattern node.
        dst_pattern_node: The destination pattern node.

    Returns:
        A dictionary representing the new assignment if valid, or None if it doesn't apply.
    """
    new_assignment = partial_assignment.copy()
    assigned_pattern_nodes = set(new_assignment.keys())
    used_candidates = set(new_assignment.values())

    # Check if the source and destination nodes are already assigned to different nodes
    if src_pattern_node in assigned_pattern_nodes and new_assignment[src_pattern_node] != src_candidate:
        return None

    if dst_pattern_node in assigned_pattern_nodes and new_assignment[dst_pattern_node] != dst_candidate:
        return None

    # Handle self-loop edges
    if src_pattern_node == dst_pattern_node:
        if src_candidate == dst_candidate:
            new_assignment[src_pattern_node] = src_candidate
            return new_assignment
        else:
            return None

    # The edge is not a self-loop, so src and dst candidates must be different
    if src_candidate == dst_candidate:
        return None

    # Case 1: Both src and dst nodes are not assigned, and the candidates are not used, assign them
    if src_pattern_node not in assigned_pattern_nodes and dst_pattern_node not in assigned_pattern_nodes:
        if src_candidate not in used_candidates and dst_candidate not in used_candidates:
            new_assignment[src_pattern_node] = src_candidate
            new_assignment[dst_pattern_node] = dst_candidate
            return new_assignment
        else:
            return None

    # Case 2: If the pattern src node is assigned with the input src candidate, but the dst node is not assigned, 
    # and the dst candidate is not used, assign them
    if src_pattern_node in assigned_pattern_nodes and new_assignment[src_pattern_node] == src_candidate:
        if dst_pattern_node not in assigned_pattern_nodes and dst_candidate not in used_candidates:
            new_assignment[dst_pattern_node] = dst_candidate
            return new_assignment
        else:
            return None

    # Case 3: If the pattern dst node is assigned with the input dst candidate, but the src node is not assigned,
    # and the src candidate is not used, assign them
    if dst_pattern_node in assigned_pattern_nodes and new_assignment[dst_pattern_node] == dst_candidate:
        if src_pattern_node not in assigned_pattern_nodes and src_candidate not in used_candidates:
            new_assignment[src_pattern_node] = src_candidate
            return new_assignment
        else:
            return None

    return None  # No valid assignment if none of the cases match

# %% ../nbs/03_matcher.ipynb 16
def _find_pattern_based_matches(graph: DiGraph, pattern: DiGraph) -> Iterator[Tuple[DiGraph, Dict[NodeName, NodeName]]]:
    """
    Find all subgraphs in the input graph that match the given pattern graph based on both structure (nodes and edges)
    and attributes (existence of attributes or constant value checks).
    
    Args:
        graph (DiGraph): The graph to search for matches.
        pattern (DiGraph): The pattern graph representing the structure and attributes to match.
    
    Yields:
        Iterator[Tuple[DiGraph, Dict[NodeName, NodeName]]]: Tuples of (subgraph, mapping),
        where subgraph is the matched subgraph, and mapping is a dictionary mapping nodes in the
        subgraph to nodes in the pattern.
    """

    # Separate self-loops from non-self-loop edges in the pattern
    self_loop_pattern_edges = [(src, dst) for src, dst in pattern.edges if src == dst]
    non_self_loop_pattern_edges = [(src, dst) for src, dst in pattern.edges if src != dst]

    partial_assignments = [{}]  # Initialize with an empty assignment

    # Step 1: Handle self-loops first, if they exist
    if self_loop_pattern_edges:
        self_loop_pattern_nodes = set(src for src, _ in self_loop_pattern_edges)
        self_loop_nodes_candidates = {node: _find_input_nodes_candidates(node, pattern, graph) for node in self_loop_pattern_nodes}
        node_candidates_filtered_by_edge = {}
        for pattern_node, _ in self_loop_pattern_edges:
            node_candidates = self_loop_nodes_candidates[pattern_node]
            node_candidates_filtered_by_edge[pattern_node] = {node for node, _ in _filter_edge_candidates(
                graph, pattern, pattern_node, pattern_node, node_candidates, node_candidates)}
        
        partial_assignments = _extend_assignments_with_nodes(node_candidates_filtered_by_edge, partial_assignments, graph) or []

        if not partial_assignments:  # If no valid partial assignments from self-loops, return early
            return

    # Step 2: Handle non-self-loop edges, if they exist
    if non_self_loop_pattern_edges:
        partial_assignments = _extend_assignments_with_edges(non_self_loop_pattern_edges, partial_assignments, pattern, graph) or []

        if not partial_assignments:  # If no valid partial assignments from non-self-loop edges, return early
            return

    # Step 3: Complete the partial assignments with remaining pattern nodes (nodes without edges)
    assignments = []
    assigned_pattern_nodes = set()
    for partial_assignment in partial_assignments:
        assigned_pattern_nodes.update(partial_assignment.keys())
        
    remaining_pattern_nodes = set(pattern.nodes) - assigned_pattern_nodes

    if not remaining_pattern_nodes:  # No remaining pattern nodes
        assignments = partial_assignments  
    else:
        remaining_node_candidates = {node: _find_input_nodes_candidates(node, pattern, graph) for node in remaining_pattern_nodes}
        assignments = _extend_assignments_with_nodes(remaining_node_candidates, partial_assignments, graph) or []

    # Step 4: Yield valid subgraphs and their assignments
    for assignment in assignments:
        subgraph = DiGraph()
        subgraph.add_nodes_from(set(assignment.values()))
        for pattern_edge in list(pattern.edges):
            graph_edge = (assignment[pattern_edge[0]], assignment[pattern_edge[1]])
            if graph_edge in graph.edges:
              subgraph.add_edge(graph_edge[0], graph_edge[1])
            else: # In that case we don't need to check the rest of the isomorphism
                break

        # Validate subgraph for isomorphism
        if isomorphism.is_isomorphic(subgraph, pattern, node_match=_attributes_match, edge_match=_attributes_match):
            yield subgraph, assignment

# %% ../nbs/03_matcher.ipynb 19
FilterFunc = Callable[[Match], bool]

# %% ../nbs/03_matcher.ipynb 22
# TODO: Not sure this is needed since we remove duplicates in the _find_pattern_based_matches function
def _filter_duplicated_matches(matches: list[Match]) -> Iterator[Match]:
    """Remove duplicates from a list of Matches, based on their mappings. Return an iterator of the matches without duplications.

    Args:
        matches (list[Match]): list of Match objects

    Yields:
        Iterator[list[Match]]: Iterator of the matches without duplications.
    """

    # We can't use a set directly because Match objects are not hashable. 
    # This is why we use a list of matche's mappings to check for duplicates.
    mappings = []
    for match in matches:
        if match.mapping not in mappings:
            mappings.append(match.mapping)
            yield match

# %% ../nbs/03_matcher.ipynb 23
def _find_intersecting_pattern_nodes(single_nodes_pattern: DiGraph, collection_pattern: DiGraph) -> set:
    """
    Find the intersecting pattern nodes between the single nodes match pattern and the collection pattern.

    The intersecting pattern nodes are those that appear in both the single nodes match pattern 
    (i.e., pattern nodes that aim to match a single, unique input node) and the collection pattern 
    (i.e., pattern nodes that aim to match multiple input nodes).

    Args:
        single_nodes_pattern (DiGraph): The pattern graph representing nodes that match single nodesly one input node.
        collection_pattern (DiGraph): The pattern graph representing nodes that match multiple input nodes.

    Returns:
        set: A set of pattern nodes that are present in both the single nodes match pattern and the collection pattern.
    """
    intersecting_pattern_nodes = set(single_nodes_pattern.nodes) & set(collection_pattern.nodes)
    return intersecting_pattern_nodes

# %% ../nbs/03_matcher.ipynb 24
def _add_collections_to_single_nodes_matches(input_graph: DiGraph, collection_pattern: DiGraph, 
                                      single_nodes_matches: List[Dict[NodeName, Set[NodeName]]], intersecting_pattern_nodes: Set[NodeName]
                                      ) -> Iterator[Dict[NodeName, Set[NodeName]]]:
    """
    Add collection matches to the existing single nodes matches by finding subgraph matches for collection pattern nodes
    and merging them with the given single nodes match mapping.

    This function finds matches in the input graph that satisfy both the single nodes match pattern (pattern nodes 
    that aim to match single nodesly one input node) and the collection pattern (pattern nodes that aim to match 
    multiple input nodes).

    Args:
        input_graph (DiGraph): The input graph.
        collection_pattern (DiGraph): The pattern graph representing nodes that match multiple input nodes.
        single_nodes_matches (List[Dict[NodeName, Set[NodeName]]]): A list of mappings for single nodes matches, in set semantics.
        intersecting_pattern_nodes (Set[NodeName]): A set of pattern nodes that are present in both the single nodes match pattern and the collection pattern.

    Yields:
        Iterator[Dict[NodeName, Set[NodeName]]]: An iterator over the updated mappings, where each includes both 
        the previous single nodes match mapping and the newly found collection matches for this single nodes match.
    """
    input_graph_copy = input_graph.copy()

    # Enrich the single nodes match mapping with the corresponding collection matches.
    for mapping in single_nodes_matches:
        non_intersecting_collection_pattern_nodes = set(collection_pattern.nodes) - intersecting_pattern_nodes
        mapping.update({pattern_node: set() for pattern_node in non_intersecting_collection_pattern_nodes})

        # Lock intersecting pattern nodes to their corresponding input node in the single nodes match
        collection_pattern_copy = collection_pattern.copy()
        for intersecting_pattern_node in intersecting_pattern_nodes:
            collection_pattern_copy.nodes[intersecting_pattern_node]['_id'] = mapping[intersecting_pattern_node]

        # Find collection matches using the locked pattern
        collection_matches = list(_find_pattern_based_matches(input_graph_copy, collection_pattern_copy))

        # Add matches for collection pattern nodes
        for collection_match in collection_matches:
            for collection_pattern_node, matched_input_nodes in collection_match.items():
                if collection_pattern_node not in intersecting_pattern_nodes: # We already have the single nodes match for these nodes
                    mapping[collection_pattern_node].add(matched_input_nodes)  # Add the matched input node

        yield mapping
