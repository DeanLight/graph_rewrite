# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_matcher.ipynb.

# %% auto 0
__all__ = ['FilterFunc']

# %% ../nbs/03_matcher.ipynb 5
from typing import *
from networkx import DiGraph
from networkx.algorithms import isomorphism # check subgraph's isom.
from .core import NodeName, _create_graph, draw
from .lhs import lhs_to_graph
from .match_class import Match, mapping_to_match ,draw_match
from itertools import product
from typing import Tuple, Iterator
from collections import defaultdict

# %% ../nbs/03_matcher.ipynb 8
def _attributes_match(pattern_attrs: dict, input_attrs: dict) -> bool:
    """
    Check if the input attributes match the pattern attributes.

    This function supports both:
    - Existence checks (ensures that required attributes exist).
    - Constant value checks (ensures that constant values match).

    Args:
        pattern_attrs (dict): Attributes of the pattern (node or edge).
        input_attrs (dict): Attributes of the input (node or edge).

    Returns:
        bool: True if the input attributes match the pattern attributes, False otherwise.
    """
    for attr_name, attr_value in pattern_attrs.items():
        if attr_name not in input_attrs:  # If the attribute does not exist, return False
            return False
        
        if attr_value is None: # If the attribute exists, but the value is None, continue to the next attribute
            continue

        if input_attrs[attr_name] != attr_value: # copares the values of the attributes (and, if the attribute type was mentioned in the pattern, compares the types)
            return False

    return True

# %% ../nbs/03_matcher.ipynb 10
def _find_input_nodes_candidates(pattern_node: NodeName, pattern: DiGraph, input_graph: DiGraph) -> set[NodeName]:
    """
    Given a pattern node and an input graph, return a set of input graph nodes that:
    - Contain the required attributes of the pattern node, including constant value checks (if specified) and existence checks (if no value is specified / no constant value).
    - Have at least one edge with matching attributes for each edge of the pattern node that has attributes specified.

    Args:
        pattern_node (NodeName): The pattern node.
        pattern (DiGraph): The pattern graph.
        input_graph (DiGraph): The input graph.

    Returns:
        set[NodeName]: A set of input graph nodes that match the required attributes and have at least one matching edge.
    """
    pattern_node_attrs = pattern.nodes[pattern_node]

    if "_id" in pattern_node_attrs:
        input_node_id = pattern_node_attrs.pop("_id")
        input_nodes_to_check = [input_node_id]
    else:
        input_nodes_to_check = list(input_graph.nodes)

    # Filter nodes by attributes first
    candidate_nodes = {
        input_node
        for input_node in input_nodes_to_check
        if _attributes_match(pattern_node_attrs, input_graph.nodes[input_node])
    }

    return candidate_nodes

# %% ../nbs/03_matcher.ipynb 11
# Helper function to check if an input edge matches the pattern edge
def _is_valid_edge_candidate(input_graph: DiGraph, pattern_edge_attrs: dict, 
                   src_candidate: NodeName, dst_candidate: NodeName, 
                   src_pattern_node: NodeName, dst_pattern_node: NodeName) -> bool:
    """
    Check if an edge between two input nodes matches the pattern edge and attributes.

    Args:
        input_graph (DiGraph): The input graph.
        pattern_edge_attrs (dict): Attributes of the pattern edge to match.
        src_candidate (NodeName): The source candidate node in the input graph.
        dst_candidate (NodeName): The destination candidate node in the input graph.
        src_pattern_node (NodeName): The source pattern node.
        dst_pattern_node (NodeName): The destination pattern node.

    Returns:
        bool: True if the input edge is valid, False otherwise.
    """
    if (src_candidate, dst_candidate) not in input_graph.edges:
        return False

    input_edge_attrs = input_graph.get_edge_data(src_candidate, dst_candidate, default={})
    if not _attributes_match(pattern_edge_attrs, input_edge_attrs):
        return False

    # Special case - self loops in pattern graph: If the source and destination are the same node in the pattern,
    # ensure the source and destination candidates are also the same in the input graph
    if src_pattern_node == dst_pattern_node and src_candidate != dst_candidate:
        return False

    return True

# %% ../nbs/03_matcher.ipynb 13
def _find_pattern_based_matches(graph: DiGraph, pattern: DiGraph) -> Iterator[Tuple[DiGraph, Dict[NodeName, NodeName]]]:
    """
    Find all subgraphs in the input graph that match the given pattern graph based on both structure (nodes and edges)
    and attributes (existence of attributes or constant value checks).
    
    Args:
        graph (DiGraph): The graph to search for matches.
        pattern (DiGraph): The pattern graph representing the structure and attributes to match.
    
    Yields:
        Iterator[Tuple[DiGraph, Dict[NodeName, NodeName]]]: Tuples of (subgraph, mapping),
        where subgraph is the matched subgraph, and mapping is a dictionary mapping nodes in the
        subgraph to nodes in the pattern.
    """
    map_pattern_nodes_to_candidates = {pattern_node: _find_input_nodes_candidates(pattern_node, pattern, graph)
                                       for pattern_node in pattern.nodes}
    
    pattern_nodes = list(map_pattern_nodes_to_candidates.keys())  # List of pattern nodes
    candidate_sets = list(map_pattern_nodes_to_candidates.values())  # List of candidate sets, matches the indexes of pattern_nodes
    
    # All possible assignments of input nodes to pattern nodes, where each input node is assigned to exactly one pattern node
    # that matches the pattern node's attributes (existence checks and constant value checks)
    assignments = [{pattern_node: input_node for pattern_node, input_node in zip(pattern_nodes, assignment)}
                   for assignment in product(*candidate_sets)]
    
    # Filter assignments that map the same input node to multiple pattern nodes or have mismatching edges
    valid_assignments = []
    for assignment in assignments:
        # Check if any input node is mapped to multiple pattern nodes
        input_node_counts = defaultdict(int) # automatically initializes to 0
        for input_node in assignment.values():
            input_node_counts[input_node] += 1
            if input_node_counts[input_node] > 1:
                break  # Skip assignment if duplicate nodes found
        else:
            # Check if edges between input nodes match the edges in the pattern 
            # (existence checks, and attributes check based on attribute existence and constant values)
            for src_pattern_node, dst_pattern_node in pattern.edges:
                src_input_node = assignment[src_pattern_node]
                dst_input_node = assignment[dst_pattern_node]
                if not _is_valid_edge_candidate(graph, pattern.get_edge_data(src_pattern_node, dst_pattern_node, default={}),
                                                src_input_node, dst_input_node, src_pattern_node, dst_pattern_node):
                    break
            else:
                valid_assignments.append(assignment)

    # We take the valid assignments and create a subgraph from them, using the matching nodes and edges from the input graph
    for assignment in valid_assignments:
        subgraph = DiGraph()
        subgraph.add_nodes_from(set(assignment.values()))
        for src_pattern_node, dst_pattern_node in pattern.edges:
            src_input_node = assignment[src_pattern_node]
            dst_input_node = assignment[dst_pattern_node]
            subgraph.add_edge(src_input_node, dst_input_node)

        # Validate subgraph for isomorphism
        if isomorphism.is_isomorphic(subgraph, pattern, node_match=_attributes_match, edge_match=_attributes_match):
            yield subgraph, assignment


# %% ../nbs/03_matcher.ipynb 15
FilterFunc = Callable[[Match], bool]

# %% ../nbs/03_matcher.ipynb 18
def _filter_duplicated_matches(matches: list[Match]) -> Iterator[Match]:
    """Remove duplicates from a list of Matches, based on their mappings. Return an iterator of the matches without duplications.

    Args:
        matches (list[Match]): list of Match objects

    Yields:
        Iterator[list[Match]]: Iterator of the matches without duplications.
    """

    # We can't use a set directly because Match objects are not hashable. 
    # This is why we use a list of matche's mappings to check for duplicates.
    mappings = []
    for match in matches:
        if match.mapping not in mappings:
            mappings.append(match.mapping)
            yield match

# %% ../nbs/03_matcher.ipynb 19
def _find_intersecting_pattern_nodes(single_nodes_pattern: DiGraph, collection_pattern: DiGraph) -> list:
    """
    Find the intersecting pattern nodes between the single nodes match pattern and the collection pattern.

    The intersecting pattern nodes are those that appear in both the single nodes match pattern 
    (i.e., pattern nodes that aim to match a single, unique input node) and the collection pattern 
    (i.e., pattern nodes that aim to match multiple input nodes).

    Args:
        single_nodes_pattern (DiGraph): The pattern graph representing nodes that match single nodesly one input node.
        collection_pattern (DiGraph): The pattern graph representing nodes that match multiple input nodes.

    Returns:
        list: A list of pattern nodes that are present in both the single nodes match pattern and the collection pattern.
    """

    single_nodes_pattern_nodes = set(single_nodes_pattern.nodes)
    collection_pattern_nodes = set(collection_pattern.nodes)
    
    return list(single_nodes_pattern_nodes.intersection(collection_pattern_nodes))

# %% ../nbs/03_matcher.ipynb 20
def _add_collections_to_single_nodes_matches(input_graph: DiGraph, single_match_pattern: DiGraph ,collection_pattern: DiGraph, 
                                      single_nodes_matches: List[Dict[NodeName, Set[NodeName]]], intersecting_pattern_nodes: List[NodeName],
                                      condition: FilterFunc = lambda match : True, filter: bool = True, warn_on_collisions: bool = True
                                      )-> list[Dict[NodeName, List[NodeName]]]:
    """
    Add collection matches to the existing single nodes matches by finding subgraph matches for collection pattern nodes
    and merging them with the given single nodes match mapping.

    This function finds matches in the input graph that satisfy both the single nodes match pattern (pattern nodes 
    that aim to match single nodesly one input node) and the collection pattern (pattern nodes that aim to match 
    multiple input nodes).

    Args:
        input_graph (DiGraph): The input graph.
        single_match_pattern (DiGraph): The pattern graph representing nodes that match single nodesly one input node.
        collection_pattern (DiGraph): The pattern graph representing nodes that match multiple input nodes.
        single_nodes_matches (List[Dict[NodeName, List[NodeName]]]): A list of mappings for single nodes matches, in list semantics.
        intersecting_pattern_nodes (List[NodeName]): A list of pattern nodes that are present in both the single nodes match pattern and the collection pattern.

    Yields:
        list[Dict[NodeName, List[NodeName]]]: A list of mappings that include the single nodes match mapping and the collection matches.
    """

    input_graph_copy = input_graph.copy()

    # Enrich the single nodes match mapping with the corresponding collection matches.
    for mapping in list(single_nodes_matches):  # We need to iterate over a copy of the list to avoid modifying it while iterating
        # Lock intersecting pattern nodes to their corresponding input node in the single nodes match
        collection_pattern_copy = collection_pattern.copy()
        for intersecting_pattern_node in intersecting_pattern_nodes:
            intersecting_input_node = list(mapping[intersecting_pattern_node])[0]  # When we get here, we know that the single nodes match has only one node for each intersecting pattern node - we can take the first element
            collection_pattern_copy.nodes[intersecting_pattern_node]['_id'] = intersecting_input_node  # Lock the intersecting pattern node to the corresponding input node

        # Find collection matches using the locked pattern
        for _, collection_mapping in _find_pattern_based_matches(input_graph_copy, collection_pattern_copy):
            # Filter matches based on the condition
            match = mapping_to_match(input_graph, single_match_pattern, collection_pattern, collection_mapping, warn_on_collisions)
            if (filter and condition(match)) or not filter:
                # Add the collection nodes mapping (not including the intersecting pattern nodes) to the single nodes match mapping
                for collection_pattern_node, matched_input_nodes in collection_mapping.items():
                    if collection_pattern_node not in intersecting_pattern_nodes:
                        mapping.setdefault(collection_pattern_node, set()).add(matched_input_nodes)

    # Now all mappings are enriched with the collection matches, we can convert the mappings to matches, and filter out duplicates
    matches = [mapping_to_match(input_graph, single_match_pattern, collection_pattern, mapping, warn_on_collisions) for mapping in single_nodes_matches]
    return list(_filter_duplicated_matches(matches))
